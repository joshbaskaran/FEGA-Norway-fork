#!/bin/sh
set -e
# Code originally generated by godownloader on 2023-08-02T19:16:30Z and then modified for the new monorepo.

usage() {
  this=$1
  cat <<EOF
$this: Download Go binaries for lega-commander from ELIXIR-NO/FEGA-Norway

Usage: $this [-b] bindir [-d] [tag]
  -b sets bindir or installation directory, Defaults to /usr/local/bin
  -t sets a specific tag (e.g. "vX.Y.Z") to install
  -d turns on debug logging
   [tag] is a tag from
   https://github.com/ELIXIR-NO/FEGA-Norway/releases
   If tag is missing, then the latest will be used.

EOF
  exit 2
}

parse_args() {
  BINDIR=${BINDIR:-/usr/local/bin}
  while getopts "b:t:dhx?" arg; do
    case "$arg" in
      b) BINDIR="$OPTARG" ;;
      t) TAG="$OPTARG" ;;
      d) log_set_priority 10 ;;
      h|\?) usage "$0" ;;
      x) set -x ;;
    esac
  done
  shift $((OPTIND - 1))
}

execute() {
  log_info "Starting execution..."

  # Determine the default BINDIR based on writable permissions
  if [ -w "/usr/local/bin" ]; then
    BINDIR=${BINDIR:-"/usr/local/bin"}
    log_info "Using '/usr/local/bin' as the installation directory."
  else
    BINDIR=${BINDIR:-"$HOME/.local/bin"}
    log_info "Default installation path changed to '${BINDIR}' because '/usr/local/bin' is not writable."
  fi

  # Ensure the final BINDIR is writable
  if [ ! -w "${BINDIR}" ]; then
    log_crit "BINDIR (${BINDIR}) is not writable. Please run with sudo or choose a writable path using the -b flag."
    exit 1
  fi

  # Create a temporary directory for downloads
  tmpdir=$(mktemp -d)
  log_info "Downloading files into ${tmpdir}"

  # Download the tarball
  log_info "Downloading tarball: ${TARBALL_URL}"
  if http_download "${tmpdir}/${TARBALL}" "${TARBALL_URL}"; then
    log_info "Successfully downloaded tarball: ${TARBALL_URL}"
  else
    log_crit "Failed to download tarball: ${TARBALL_URL}"
    exit 1
  fi

  # Download the checksum
  log_info "Downloading checksum: ${CHECKSUM_URL}"
  if http_download "${tmpdir}/${CHECKSUM}" "${CHECKSUM_URL}"; then
    log_info "Successfully downloaded checksum: ${CHECKSUM_URL}"
  else
    log_crit "Failed to download checksum: ${CHECKSUM_URL}"
    exit 1
  fi

  # Verify the checksum
  log_info "Verifying checksum..."
  hash_sha256_verify "${tmpdir}/${TARBALL}" "${tmpdir}/${CHECKSUM}"
  log_info "Checksum verification passed."

  # Extract the tarball
  log_info "Extracting tarball..."
  srcdir="${tmpdir}"
  (cd "${tmpdir}" && untar "${TARBALL}")
  log_info "Extracted tarball."

  # Create the BINDIR if it doesn't exist
  if [ ! -d "${BINDIR}" ]; then
    mkdir -p "${BINDIR}"
    log_info "Created installation directory: ${BINDIR}"
  else
    log_info "Installation directory already exists: ${BINDIR}"
  fi

  # Install the binaries
  for binexe in $BINARIES; do
    if [ "$OS" = "windows" ]; then
      binexe="${binexe}.exe"
    fi
    log_info "Installing ${binexe} to ${BINDIR}/"
    install "${srcdir}/${binexe}" "${BINDIR}/"
    log_info "Installed ${BINDIR}/${binexe}"
  done

  # Clean up the temporary directory
  rm -rf "${tmpdir}"
  log_info "Cleaned up temporary files."

  log_info "Installation completed successfully."
}

get_binaries() {
  log_info "Determining binaries for platform: ${PLATFORM}"
  case "$PLATFORM" in
    Darwin/386) BINARIES="lega-commander" ;;
    Darwin/x86_64) BINARIES="lega-commander" ;;
    Darwin/arm64) BINARIES="lega-commander" ;;
    Linux/386) BINARIES="lega-commander" ;;
    Linux/x86_64) BINARIES="lega-commander" ;;
    Windows/386) BINARIES="lega-commander" ;;
    Windows/x86_64) BINARIES="lega-commander" ;;
    *)
      log_crit "Platform $PLATFORM is not supported. Please file a request at https://github.com/${PREFIX}/issues/new"
      exit 1
      ;;
  esac
  log_info "Binaries to install: ${BINARIES}"
}

tag_to_version() {
  if [ -n "$TAG" ]; then
    # User explicitly provided a tag
    REALTAG="$TAG"
    log_info "Using user-specified tag: $REALTAG"
  else
    # Auto-fetch the latest
    log_info "Checking GitHub for the latest tag"
    REALTAG=$(github_get_latest "$OWNER/$REPO") || {
      log_crit "Failed to find the latest tag."
      exit 1
    }
  fi

  log_info "REALTAG: $REALTAG"

  REALTAG=$(echo "$REALTAG" | tr -d '[:space:]')

  case "$REALTAG" in
    v*)
      VERSION=${REALTAG#v}
      TAG="$REALTAG"
      ;;
    lega-commander-*)
      VERSION=${REALTAG#lega-commander-}
      TAG="v${VERSION}"
      ;;
    *)
      VERSION="$REALTAG"
      TAG="v${REALTAG}"
      ;;
  esac

  log_info "VERSION: $VERSION"
  log_info "TAG: $TAG"
}

adjust_format() {
  true
}

adjust_os() {
  true
}

adjust_arch() {
  true
}

cat /dev/null <<EOF
------------------------------------------------------------------------
https://github.com/client9/shlib - portable posix shell functions
Public domain - http://unlicense.org
Credit appreciated.
------------------------------------------------------------------------
EOF

is_command() {
  command -v "$1" >/dev/null
}

echoerr() {
  echo "$@" 1>&2
}

_logp=6
log_set_priority() {
  _logp="$1"
}
log_priority() {
  [ "$1" -le "$_logp" ]
}
log_tag() {
  case $1 in
    0) echo "emerg" ;;
    1) echo "alert" ;;
    2) echo "crit" ;;
    3) echo "err" ;;
    4) echo "warning" ;;
    5) echo "notice" ;;
    6) echo "info" ;;
    7) echo "debug" ;;
    *) echo "$1" ;;
  esac
}
log_debug() {
  log_priority 7 && echoerr "$(log_prefix)" "$(log_tag 7)" "$@"
}
log_info() {
  log_priority 6 && echoerr "$(log_prefix)" "$(log_tag 6)" "$@"
}
log_err() {
  log_priority 3 && echoerr "$(log_prefix)" "$(log_tag 3)" "$@"
}
log_crit() {
  log_priority 2 && echoerr "$(log_prefix)" "$(log_tag 2)" "$@"
}

uname_os() {
  os=$(uname -s)
  case "$os" in
    cygwin_nt*) os="windows" ;;
    mingw*) os="windows" ;;
    msys_nt*) os="windows" ;;
  esac
  echo "$os"
}

uname_arch() {
  arch=$(uname -m)
  case $arch in
    x86_64) arch="x86_64" ;;
    x86) arch="386" ;;
    i686) arch="386" ;;
    i386) arch="386" ;;
    aarch64) arch="arm64" ;;
    armv5*) arch="armv5" ;;
    armv6*) arch="armv6" ;;
    armv7*) arch="armv7" ;;
  esac
  echo "${arch}"
}

uname_os_check() {
  os=$1
  case "$os" in
    Darwin|Dragonfly|Freebsd|Linux|Android|Nacl|Netbsd|Openbsd|Plan9|Solaris|Windows)
      return 0 ;;
    *)
      log_crit "uname_os_check '$os' is not a GOOS value."
      return 1 ;;
  esac
}

uname_arch_check() {
  arch=$1
  case "$arch" in
    386|x86_64|amd64|arm64|armv5|armv6|armv7|ppc64|ppc64le|mips|mipsle|mips64|mips64le|s390x|amd64p32)
      return 0 ;;
    *)
      log_crit "uname_arch_check '$arch' is not a GOARCH value."
      return 1 ;;
  esac
}

untar() {
  tarball=$1
  case "${tarball}" in
    *.tar.gz|*.tgz) tar --no-same-owner -xzf "${tarball}" ;;
    *.tar) tar --no-same-owner -xf "${tarball}" ;;
    *.zip) unzip "${tarball}" ;;
    *)
      log_err "untar unknown archive format for ${tarball}"
      return 1 ;;
  esac
}

http_download_curl() {
  local_file=$1
  source_url=$2
  header=$3
  if [ -z "$header" ]; then
    code=$(curl -w '%{http_code}' -sL -o "$local_file" "$source_url")
  else
    code=$(curl -w '%{http_code}' -sL -H "$header" -o "$local_file" "$source_url")
  fi
  if [ "$code" != "200" ]; then
    log_crit "Download failed for $source_url with HTTP code $code"
  fi
  [ "$code" = "200" ]
}

http_download_wget() {
  local_file=$1
  source_url=$2
  header=$3
  if [ -z "$header" ]; then
    wget -q -O "$local_file" "$source_url"
  else
    wget -q --header "$header" -O "$local_file" "$source_url"
  fi
  if [ $? -ne 0 ]; then
    log_crit "Download failed for $source_url using wget"
  fi
}

http_download() {
  log_debug "http_download $2"
  if is_command curl; then
    http_download_curl "$@" || {
      log_crit "http_download failed with curl"
      return 1
    }
  elif is_command wget; then
    http_download_wget "$@" || {
      log_crit "http_download failed with wget"
      return 1
    }
  else
    log_crit "http_download unable to find wget or curl"
    return 1
  fi
}

http_copy() {
  tmp=$(mktemp)
  http_download "${tmp}" "$1" "$2" || return 1
  body=$(cat "$tmp")
  rm -f "${tmp}"
  echo "$body"
}

github_get_latest() {
  owner_repo="$1"

  # 1) Get all releases as JSON
  releases_json=$(http_copy "https://api.github.com/repos/${owner_repo}/releases" \
                             "Accept:application/vnd.github.v3+json") || {
    log_crit "Failed to list releases from GitHub."
    return 1
  }

  #Extract all tag_name fields, filtering those that begin with "lega-commander-"
  #Then parse out the version portion after 'lega-commander-'

  cmd_results=$(
    echo "$releases_json" |
      sed -n 's/.*"tag_name":[[:space:]]*"\([^"]*\)".*/\1/p' |
      grep '^lega-commander-' |
      sed 's/^lega-commander-//'
  )

  if [ -z "$cmd_results" ]; then
    log_crit "No releases found with tag_name starting 'lega-commander-'."
    return 1
  fi

  # Sort them descending and pick the top
  latest_version=$(printf "%s\n" "$cmd_results" | sort -rV | head -n1)

  # Rebuild the final tag name
  latest_tag="lega-commander-$latest_version"

  echo "$latest_tag"
}



github_release() {
  owner_repo=$1
  version=$2
  [ -z "$version" ] && version="latest"
  if [ "$version" = "latest" ]; then
    giturl="https://api.github.com/repos/${owner_repo}/releases/latest"
  else
    giturl="https://api.github.com/repos/${owner_repo}/releases/tags/${version}"
  fi
  json=$(http_copy "$giturl" "Accept:application/vnd.github.v3+json") || return 1
  # Extract the tag_name field using POSIX-compliant whitespace matching
  version=$(echo "$json" | tr -s '\n' ' ' | sed -n 's/.*"tag_name":[[:space:]]*"\([^"]*\)".*/\1/p')
  [ -z "$version" ] && return 1
  echo "$version"
}

hash_sha256() {
  TARGET=${1:-/dev/stdin}
  if is_command gsha256sum; then
    hash=$(gsha256sum "$TARGET") || return 1
    echo "$hash" | cut -d ' ' -f 1
  elif is_command sha256sum; then
    hash=$(sha256sum "$TARGET") || return 1
    echo "$hash" | cut -d ' ' -f 1
  elif is_command shasum; then
    hash=$(shasum -a 256 "$TARGET" 2>/dev/null) || return 1
    echo "$hash" | cut -d ' ' -f 1
  elif is_command openssl; then
    hash=$(openssl dgst -sha256 "$TARGET") || return 1
    # Output looks like: SHA256(<file>)= <hash>
    echo "$hash" | awk '{print $2}'
  else
    log_crit "hash_sha256 unable to find command to compute sha-256 hash"
    return 1
  fi
}

hash_sha256_verify() {
  TARGET=$1
  checksums=$2
  [ -z "$checksums" ] && {
    log_err "hash_sha256_verify checksum file not specified"
    return 1
  }
  BASENAME=${TARGET##*/}
  want=$(grep "${BASENAME}" "${checksums}" 2>/dev/null | tr '\t' ' ' | cut -d ' ' -f 1)
  [ -z "$want" ] && {
    log_err "hash_sha256_verify unable to find checksum for '${TARGET}' in '${checksums}'"
    return 1
  }
  got=$(hash_sha256 "$TARGET")
  [ "$want" = "$got" ] || {
    log_err "hash_sha256_verify checksum for '$TARGET' did not match. Expected $want, got $got"
    return 1
  }
}

# Source: https://github.com/client9/shlib - portable posix shell functions
cat /dev/null <<EOF
------------------------------------------------------------------------
https://github.com/client9/shlib - portable posix shell functions
Public domain - http://unlicense.org
Credit appreciated.
------------------------------------------------------------------------
EOF

PROJECT_NAME="lega-commander"
OWNER="ELIXIR-NO"
REPO="FEGA-Norway"
BINARY="lega-commander"
FORMAT=tar.gz
OS=$(uname_os)
ARCH=$(uname_arch)
PREFIX="$OWNER/$REPO"

log_prefix() {
  echo "$PREFIX"
}

PLATFORM="${OS}/${ARCH}"
GITHUB_DOWNLOAD="https://github.com/${OWNER}/${REPO}/releases/download"

uname_os_check "$OS"
uname_arch_check "$ARCH"

parse_args "$@"

get_binaries
tag_to_version
adjust_format
adjust_os
adjust_arch

log_info "found version: ${VERSION} for ${TAG}/${OS}/${ARCH}"

NAME="${BINARY}_${OS}_${ARCH}"
TARBALL="${NAME}.tar.gz"
CHECKSUM="${BINARY}_${VERSION}_checksums.txt"

TARBALL_URL="${GITHUB_DOWNLOAD}/${TAG}/${TARBALL}"
CHECKSUM_URL="${GITHUB_DOWNLOAD}/${TAG}/${CHECKSUM}"

execute
